
# Discussion

<https://twitter.com/kanzure/status/1168891841745494016>

Chris Howe make a damn good start of a C version of Shamir secret sharing. We need to take it another level. This could be another project that we could engage on. We also didn't finish the actual paper, as such. I'd like to get both of those things resolved.

SatoshiLabs is saying that as far as they are concerned SLIP 39 is done and they are not interested in feedback or changing it or adapting it, at the words level. They just don't want to touch it. It seems like they are shipping it or are they manufacturing it already. On the other hand, they are fine if our libraries and things are abstracting the secret sharing from the encoding that allows for more functionality. The other trick is that there is some kind of header that you can kind of do-- since there is a checksum, you can change the header and see if the checksum is valid. So you can have a hacky way of doing a version which would allow you to use the encoding for other things. With their software, it would just checksum out and the checksum would be invalid because they assume the header would be the same.

They are willing to come in for a day. We also want to work on a custom secure chip. They are interested in the RISC-V architecture and various discussions about what is the minimum viable bootstrap for a secure chip and those kinds of issues. They would like to come in for a day, we should decide what day we would like them to come in, for either of those topics. They are here in Prague too but not physically here. So that's awkward.

The HTC people are here right now; they have effectively forked the Trezor sourcecode base and they run the Trezor source code in the executable environment of the trust zone. So it's more secure than a Trezor, and Trezor might not like that. I don't think it's competition; I would love to figure out how to engage with the SatoshiLab folks. Their comment was that the roadmap is on their website and all of their github issues are too, so why can't we work with them on this?

Adding write-once to HTC's TEE might require hardware changes. A Java Card is available for HTC. All of your fast memory chips are Secure Java cards because that's how they do fast memory. They are very interested in stuff and very supportive and they have a budget.

A tradeoff documents for Shamir secret sharing, multisig, verifiable secret sharing, and others. I would prefer to write code.

You split out the key into shares for each individual. That's a 256 bit number. So you can interpret this as a private key. It wasn't originally a private key, but you can use it as one. That's a secret that the owner of the share has. So the integrator can get a signed statement about what it should be signing, signed by that share. This is separate from the partial signatures approach. The signature you get here is not usable for blockchain signatures. The device can see 3-of-4... it's a way to communicate the request. If you had partial signatures, you wouldn't need the integrator and you could do it yourself, but that would require Schnorr or Taproot or whatever. Partial signatures are already viable as long as you can use Schnorr signatures.

Our goal is to have a decision about what it is that we want to try to do for this week. I think there's a lot of alignment here for things past this week. Let's gauge that and talk about the bigger issues. We talked about SatoshiLabs. I met with them recently. It was an interesting discussion. As far as objectives for Rebooting Web of Trust, I would love to finish that paper we started after rwot8 on just the peirls and promise of Shamir secret sharing. Do you guys feel like you want to work on the C library this week?

For the C library-- the previous Shamir implementation that was in the github repo had a bunch of countermeasures for sidechannel attacks. What I wrote didn't use those at all. There's certainly something to be done bringing that way of doing the gf256 arithmetic into my implementation. We can do tests. Daan's library was the most solid I was able to find. Take your implementation as a basis, but implement it into Daan's library. Either way. I am also interested in python bindings. I'd like the C code to have python bindings that more or less mirror SatoshiLab's implementation so that I can get rid of their code.

<https://github.com/trezor/python-shamir-mnemonic/blob/master/shamir_mnemonic/__init__.py>

Leohoven tends to take an adversarial approach to implementations. The students attack each other's code pretty hard. So by the time you get through their doctorate program, you've got a lot of adversaries that you have overcome.

So one thing we could do is python bindings and sidechannel resistance for a Shamir secret sharing library or integrating with Daan's library. Given the discussions with the SatoshiLabs people, they really don't want us to touch or change or adapt anything in the encoding aspect of SLIP 39. So how it takes the 512-byte secret and turns it into a 33 byte... So for the 256 bit, it's 33, for the 128 bit, it's 20. They don't want to change that. They have basically already put in orders for new hardware that supports this. They have committed to this path. They are open, though, to not blocking or being problematic about other layers getting built on this, like the stuff other than encoding into text. They are interested in supporting more features. Like sharing through the HTC secure network to the peers, they don't see what the words are, you can basically send them binary information instead. We should have a scheme for adding in the information that you want to store.

The format should include a memo field and also hashes of the other pieces so that you can be confident. They are arguing that you would only use this once every 5 years so it should be as short as possible. If you add more metadata, it's more information for the attacker. But I hate security by obscurity, so I would rather see it go in the other direction. We could use a varint for days since 1970 very easily. That would be 2 bytes for the birthday if you're worried about the space. You can store metadata outside the secret. So there could be another format, and the secret gets embedded in that other format. But that other format should still be specified.

The other thing that Daan's code does is that he assumed you might have a small, low entropy secret. He did something so that the entropy was spread... if you use Shamir secret sharing purely with low entropy secrets, it's more vulnerable. That's not required with a cryptographic key, because you already know it ought to be random to start off. I'm not sure which defensive programming assumption we want to take. We should have a more firm architecture between the encoding and the Shamir part and the pre-Shamir part of how do you choose your shares and some of the parameters. So if you have a short non-key secret, then you should generate a random key to encrypt that secret, keep the encrypted secret blob, and the Shamir shares of the key.

There is no upgradeability, by design, in any of the SLIP 39 stuff. They didn't want upgradeability. They said they would support any kind of binary standard for Shamir, which they are open to version information for that stuff. Their version byte says "SL" Satoshi Labs or something... so that makes it worse. It's also the initial vector for some other crypto stuff. They want you to check the checksum against the different IV values for different versions, but it's weird. Do we want to do a BIP instead, that isn't the Satoshi Labs one?

The SLIP 39 proposal has a lot of issues. The group stuff it has for specifying groups of thresholds isn't worth a lot. There's the 2 layer social key recovery thing. It's their way of doing it, which isn't what we specified at all. It lets you say-- do thresholding at a second layer, so it's k-of-n groups and for each group there's a different threshold. Most of the use cases I've considered or heard from anyone involves having different subgroups with different subthresholds based on which groups are selected. So say you have 4 groups, and you required within those, thresholds of 4-of-5, 4-of-7, etc., but if a different group of the high-level groups have a higher threshold, you might not need as much threshold as the other one. The reason why you would want to do this is not just micro-optimization but it's because you're trying to reduce the risk of loss. You're setting different thresholds so it's unlikely all the groups are going to experience catastrophic loss. These are separate splits.

I don't understand how the math would work for that. They are separate splits. They are somehow linked together. If a particular group appears in one instance as a 3-of-5 and another one as 4-of-5, there are two separate subkeys for that group. My second objection is that this seems much more complex to convey to users. That was our observation from rwot8, that this needs a good user interface design. There was an idea presented there about trust circles or social circles. The reason for the 2 levels is that, while you could nest this as much as you want, two layers is enough where if you had more than that it would be too confusing to users. But how do you represent the tradeoff about representing thresholds? This is why I wanted some of the UX people down here.

At the top layer, you have groups that as a group have specific trust in common. So one of the groups that was here, that was here last time at rwot8 was Ricachet, and they wanted to give out shares to your 100 instant messenger friends as one of the circles. So there they are going for resilience. Maybe it requires only 4 of the 100 to be restored. But because of that, you want to maybe have a family circle that must be able to have their quorum be reached. You want a mix of motivations. Statistically, you want their risk to be independent, which helps you better estimate likelihood of loss. As more groups are added with resilience, even if you require the same number of keys, you might be requiring it from independent groups that are unlikely to experience loss at the same time.

One thing that we could do is a template where we provide like 3 default templates for the users, and they could make an advanced one if they want. SLIP 39 doesn't let you use 4-of-100 because the numbers are limited to like 16. Technically you could have 100 shares, but you would have to strategically break it up into 14 or 16 shares each time. You're not getting this tradeoff, it's just a group of up to 16, and then there could be 16 groups,s o you can work out how many total people you have, but you might want to repeat them across groups too.

The benefit of SSS was large threshold groups. Multisig on bitcoin can't do that without paying high fees and doing presigned chains of transactions to have large multisig groups.

The threshold musig stuff that has been done since last time is drop-in replaceable. It's Shamir secret sharing on the secp curve. Besides the alignment with Bitcoin Core, this gives us a use for the musig work in the context for group signatures that aren't for authorizing bitcoin payments. There's at least five papers in this community where people are asking, how do we let a community sign for something? Especially when you talk about privacy-enhancing things, the wonderful thing about Schnorr is that in the end to verify that final signature, nobody can differentiate it from a single signer versus 100 people signing something. In the end, it's just a single Schnorr signature which helps for better privacy.

This links up with social key recovery. They can't sign for your bitcoin, because bitcoin doesn't support Schnorr yet, but they could sign a message on your behalf indicating something for some other protocol, in addition to being able to recover your bitcoin key.

Under Wyoming law, stockholders can be represented by keys, and all of the records of the company can be represented by cryptographic transactions now. So now we have the ability to say yes, the stockholders did sign the change of policy proposal or the new articles of incorporation because the old articles say it requires 60% of the shares and here are 60% of the shares signing to approve the change. There is also accountability and non-accountability issues that you can grapple with; Pieter Wuille had the tree signatures proposal.

There is no way to make multisig have cryptographic accountability, but you can prove it. So they could say, by protocol, you do sign-to-contract and who has signed would be part of it. You would need the signing threshold people use the right protocol. They can disable that if the entire signing threshold of people are colluding, which is true, but they could also take the bitcoin and do anything they want. In Shamir, if you give those people share, then those people as a group have 100% of control over that information. So that's the same there still.

There's a lot of stuff in the SLIP 39 spec that makes me nervous. The encryption I am not sure if that's secure, it doesn't look like it. We need to get bids from various parties to review parts of SLIP 39.

The feedback I got from Andrew was that there is a pull request for threshold signatures against Blockstream's version of the library. They aren't confident in the code (or it's not implemented) for the interactive protocol. This is using the shares to create a Schnorr signature. So they are also waiting for Schnorr and taproot to finalize for bitcoin, but they haven't looked at the idea of using this as an alternative to Shamir secret sharing. There's a concern about setup where everyone chooses their own share and they might sneakily choose one that is canceling someone else's shares. There's none of that when there's a delegator and he splits up the secret himself.

So we're thinking one thing we could do is write a BIP that is an alternative to SLIP 39 fixing some of the mistakes or strangeness.

When you start doing thresholds, you need much larger mnemonics. The number of shares increases at least linearly.

You could use a strict version of miniscript to do this, so that you can have support for arbitrary monotone boolean functions. Potentially you don't want to be on gf256 because the share space can grow much larger... the number of shares can be much larger than the size of that field.

We could implement something like monotone boolean functions with Daan's implementation of Shamir secret sharing, using miniscript either the C++ implementation or rust implementation.

# References

Some references:

* <https://github.com/WebOfTrustInfo/rwot8-barcelona/blob/master/topics-and-advance-readings/social-key-recovery.md>
* <https://github.com/satoshilabs/slips/blob/master/slip-0039.md>
* <https://github.com/WebOfTrustInfo/rwot9-prague/blob/master/topics-and-advance-readings/verifiable-secret-sharing.md>
* <https://github.com/BlockchainCommons/sss>

# Abstract

Social key recovery allows users to collaborate with each other to securely recover their secrets instead of using centralized account reset procedures. Shamir secret sharing is an increasingly popular implementation for social key recovery, where a secret can be split into a number of shares with various threshold requirements or in the future any arbitrary monotone boolean function.

SatoshiLabs' SLIP 39 is one proposed implementation of Shamir secret sharing with mnemonics. SLIP 39 is Simple Shamir Secret Sharing plus a two-level fixed threshold group, and a mnemonic text encoding scheme, and an encryption scheme as well.

We are uncomfortable with some of the decisions in SLIP 39 and uncomfortable with the fact that they are all bound together tightly. In light of this, we are writing a Bitcoin Improvement Proposal that is loosely inspired by SLIP 39. In this BIP, the proposal includes a binary format, additional metadata (such as birthdate), allows for the greater flexibility of thresholds, optional pre-defined pre-parameterized threshold requirement templates, and one of the goals is to make the design so that it is possible to independently audit the independent parts of the proposal, making the proposal more modular. It will also be compatible with future upgrades like verifiable secret sharing and MuSig.

We are looking forward to championing this proposal in the community, collecting feedback, and driving the improvement proposal process. We also propose to make an implementation as required by the BIP process.

# 2019-09-04

* TODO: better python bindings for libsecp256k1-zkp ?
* python bindings for Daan's SSS library

SatoshiLabs has already conducted beta testing for SLIP 39. They are releasing it tomorrow. Changing the firmware would be problematic for them.

We're not going to address on the mnemonics. We're interested in a version 2 where the focus is a binary output that can be used for more interactive. Yes, that makes sense. We can have a standard that works for binary and works with various extensions that people want to use. So far we have been talking about Shamir secret sharing, but we want to enable VSS and MuSig capabilities in the future.

Some open concerns or questions were the nature of the implementation of the two level threshold in SLIP 39. So our question is whether we want to go with a different approach of how we do the two-layer approach. Templates make sense. In some business situations, the 16-of-16 limit--- the people at Richocet want to give out 100 shares. These wouldn't be given out as mnemonics, they will probably be given out as binary. In the binary format, it's perfectly okay to use many more shares. The point is that we wanted to keep the mnemonics short. Nobody is going to use 256-sized mnemonics.

If you have 500-of-1000, surely the share will be of fixed size? Every single word you add-- it's not individual words, it's the size of the metadata. We wanted to restrict it to some reasonable limits. So that's why we restricted it to 16.

There was discussion of using secp256k1 for the BIP. This would theoretically allow us to have compatibility to go in the direction for verifiable secret sharing. One idea was to use miniscript for the threshold requirements. This might be out of scope for the next 3 days though. We could do a reduced binary serialized miniscript. Just ANDs, ORs, threshold trees with a small binary encoding.

We want to have python bindings to Daan's C library. Howe proposed making better python bindings for libsecp256k1. You can't get the field part of it. secp treats all of its internal data structures as opaque. This would require writing some interface functions. This would be a fork of libsecp256k1 that implements threshold multisignature keyspace, and then exposes that to the bindings. There's a pull request in the Blockstream libsecp256k1-zkp. But their fork is going in the wrong direction. Their library is used for Blockstream Liquid. They have a PR that adds experimental stuff, like the threshold signatures.

Any wishlist things for SLIP 39? For Trezor, we think SLIP 39 is the best thing for hardware wallets that we have right now. We're not too curious about the binary format but we're willing to cooperate and throw our two cents in. SLIP 39 is intended for users writing down mnemonics on paper. With Daan's library, they send in a binary format to another phone. We use a PIN code to verify the public keys. They have an android app and iphone app signed by them that have the public keys in them so that they can receive these messages. It's a 3-of-5, so it has to be deprecated in Q2 2020 by HTC. Maybe offer more templates than the 3-of-5 that they offer right now. They also want to introduce a pruned full node on the node, and without the birthday metadata it requires the user to pick a this key was created date otherwise we would have to rescan the whole blockchain which on a pruned node takes 2 weeks. You can put down the birthday next to the SLIP 39 of course. The scenario is, someone says I want to use the key that was generated on some other hardware wallet, on the phone, and the only export they have is the SLIP 39 recovery words or whatever. We don't have Justin here, so I can't make decisions for the HTC team. So it's an optional restore and optional save.

We can still do mnemonics. We can defer the question of yet another mnemonic scheme, right now.

Threshold signatures pull request for libsecp256k1-zkp <https://github.com/ElementsProject/secp256k1-zkp/pull/46>

How can this be made more modular? Even without a mnemonic encoding thing, we should have a separate binary encoding module. We put a number of things out of scope for this BIP, and not just because of our compressed time. bech32 encoding is out of scope as well. The encryption scheme is out of scope as well.

So why is there the encryption in SLIP 39? What is the necessity for that? Why the choices of that symmetric algorithm? If you know bip39, then you're familira with the passphrase. This is the passphrase trick. It's like a password, but it also serves for plausible deniability. Whatever passphrase you enter, it gives you a valid wallet. You can have several wallets for your mnemonics. Each one is derived with a different passphrase. You can have one decoy wallet that you can use and be deniable. There's no way to check the passphrase in the standard, and that's a design goal that was used when we were designing this. It lacks authentication and integrity and it looks like bad crypto. But this is because this was one of the design goals.

We decided to not add to SLIP 39 where you can have more shares you can get the recovery key... we didn't want to make it too complex. The idea was that something about some inheritance shares which could be used as supershares or something like that. It's the mathematics behind it, not the specification. This can be added in the future very easily.

Should there be a checksum on the extra word in bip38-- that's what Lawrence did in the first variant of GreenAddress, he added the checksum there. In bip38, you still have the normal encoding of the bip39 words. But before you transform it into an xpub, you also add in (or it might be a hash or something) the entropy from the passphrase. In bip39, there was a PBKDF of 2, making it difficult to bruteforce. It's reversible in this case though. bip38 doesn't have any checksum on that extra word, it can be anything. It can even technically be binary. Errors in the 13th and 25th words seem to be one of the most common causes of total loss of funds and loss of recovery words, are errors in that word. They restored a wallet with the 25th word, they didn't type it exactly right and didn't confirm that the address was reproducible and whatever. So in the case of GreenAddress, they basically allow you to export that 25th word with a checksum.

Instead of an integrated specification that says how to do all of this, we're going to specify a binary encoding, and then there will be another BIP in the future that says this is how you turn a binary string into a set of words for backup purposes. If the final word is treated differently than the rest of it, that's irrelevant. So you can have two separate binary encodings, one for the core piece which is checksumed, and one for the final piece, or you checksum the whole thing.

You have a root wallet, which normally uses the bip32 method of deriving subkeys. But the 13th and 25th word allows for alternative or deniable wallets. So in our binary encoding, do we say, here is the root 512 bits for the master key, and here is 6 other wallets. Deniability can be an optional feature. People are going to want to encode the 2 words for their deniable and non-deniable wallet... the Wasabi coinjoin, everything in there is using this. You can't use Wasabi without that extra word. Users will expect to be able to encode into their user shares these extra entropy things. Not sure if we need to support this in the base BIP, but we need to know that this is in addition to birthdays that someone might optionally want to add to the binary.

You might not want that in your share? Maybe you're right. My take on it is, the number one loss mechanism is people improperly backing up that share. You make it less reliable when now there's one more piece of information that they have to backup or share in another way. The binary format should allow them to completely restore everything that they need. So then technically that word is a set of words, here are all the ones that I care about. In effect, it's subwallets.

If you have a deniable wallet and it has one extra recovery word, then you need a 100 bit passphrase or something to make this ungrindable. The 25th word is a "word" but it can be a passphrase. In bip39, the 25th word was allowed to be UTF encoding, but in bip38 we limited it to ASCII.

I never liked that field because the way you would end up using deniability in this context ends up destroying the secure things you're doing to protect your secret. You should not be giving up your secret, even a deniable one, to prove how much funds you have. When you do that, you have reduced your real wallet to the security of the passphrase, which is a huge downgrade from the previous setup you have. So we have this nice scheme for Shamir secret sharing and putting shares in safety deposit boxes, and then you give up the deniable wallet, and now it changes completely.

This might be useful for (COMPANY REDACTED), but it's not a good user interface to push on my mom for instance. But Mystery Company isn't going to use the 25th word-- they don't care about it. Your operational setup might make it not relevant, but the concern is kidnapping. You say to the attacker, look, I only control x% of the coins that are under custody. But people don't really have the keys on them anyway, in that operational setup.

You can use an envelope-encoding protocol. I think it's separate. Here's the 512 bits, and here's things like birthday and some number of extra wallets-- you might have several of these. Wasabi does this. You can design a protocol for specifying, given a secret, here is how you modulate it to--- this is basically what bip32 does. And have an encoding for those shares and those secrets as well. This is a separate discussion though.

The miniscript policy specification, you can at any point truncate in the middle. You have a tree specifying how to split out, and then you have a subtree which is the fake one and it's part of the larger one. To recover the whole wallet, you need to have the other part of the tree that is invisible. This lets you basically have nested key encodings and you stop the-- you extract out a subtree somehwere and make it an actual wallet. But people know you have one other branch that is secret split another way, and that needs to be recovered another way.

Right now we don't know what the optional data fields are going to be, but some candidates include birthdate (like days since 1970 which is easy to convert from unix epoch time). In CHECKSEQUENCEVERIFY, it's 512 second chunks. Yes, using that is fine. 600 seconds to a block, so it's approximately one block. Additional deniability features, like SLIP 39, would be nice. What about other metadata that might want to be shared in a longer binary secret? Metadata information about how many other shares are required and what the hash of the secret is, so you can verify you have reconstructed the correct secret.

For future extendibility, you want payload slots both inside and outside the share for adding metadata that we haven't thought of yet. The open question is, how much do we want to have outside the format? So presumably something that is outside the share is in every share, is that correct? In the scheme that I have imagined ,you have an arbitrary variable length string that you use for containing whatever information you want. You AES encrypt that with the secret, which is recoverable. So that's your metadata you can attach, and any one of the shares can have that, and they all have the encrypted blob, and to decrypt that you need to recover the full secret and then decrypt using a key.

But external information would be, I can look at a share and before reconstrucgint the secret, I know whether I can reconstruct it with some-- yes, the script policy needs to be outside the share. You need to have the policy for how the split is performed. We need some terminology here. You need to have the coordinate you're using to do the Shamir polynomial. If it's just simple Shamir, then that has to be there. The point on the curve, you have to have that. It happens that if you're just doing threhsolds, then you can just put them together and get the answer out. You do need to know how many and know the threshold, because if you don't have enough then you can get the wrong answer. If you have arbitrary AND and OR threshold trees, then you need to know that script policy. There is a minimal argument that you must have something that exists in this external outside-the-envelope container.

Is there anything besides that policy string that you need to encode? Family identification, that this thing belongs to this family of things. I could easily have 12 different share families or groups. Or maybe I have 3 different secrets, and I am going to split them up into completely different shares. I am going to distribute these around. When I'm gathering them up, I don't want to mix the families up or mix the shares from secret A up with the shares from secret B.

It can be free-floating information, but it must be in common with all the shares in the family. Say I have opened a safe deposit box, and it has a laminated piece of information and it has the words and the script policy and it has other information like its author. Is it important that the person who just found the document learns the creator information was cryptographically tied to the share? Bogus information here can be a real threat, when you bring the shares together. If it's cryptographically tied, does it need to be verified that this is the case before the keys are reconstructed? This idea of it being part of a family is really important. If you have two secrets and create shares for them, and they get disbursed, when they come back together they must not be mixed up and you want to sort them the right way- you could get garbage or malicious people doing bad things to your reconstruction.

Hashing and signing it, makes this less deniable. The deniability is only in the passphrase. If there's metadata in the share that is signed by the original key or master secret. There's a master secret you use to derive the wallet, but there's some pre-master secret that exists before you add the passphrase. You combine the shares to get the pre-master secret, then you apply the passphrase to get the master secret. We could be tlaking about the pre-master secret, which is not relevant for the question of plausible deniability. We already have something you talked about, in SLIP 39, is the identifier-- which is just a random number that we generate and we put it in front of each share which ensures the procedure you described. I like that idea, yes.

What's going on with bip39 and Lightning Labs recovery? I think they modified bip39 somehow to have a birthdate. I think they do that also. Their main motivation was that you can't go from an xpub back to recovery words. So they have a reversible....

# Terminology

What do we call the whole thing? The total totality of the set. What's the whole package going to be called? In Shamir's original paper, he talked about dealing, and then reconstructing to build the secret back. You kind of have to create all the shares at the beginning in the deal. So is this called a "family"? A "deal"? Totality set. But "set" is used for everything. At Unchained, they were using "groups of shares" as "family". We liked the "circle" metaphor for the first level of shares. Circles and families. Is it called "the full deck", "the family deck", and "deal" is the verb. At some point, I "collect" and "reconstruct". It's beyond what you need to reconstruct. "Extended family" or "full deck". For now, let's go with full deck.

Quorum is a policy script. It's not just a number. When we have a qourum, which is some number of these shares, non-sequential etc., that's sufficient to recover the secret.

We need an area visible before construction, and one that is only visible after reconstruction.

In SLIP 39, the "share value" is the actual mathematical value. Then the rest was "share mnemonic". I like "share value", because that's what goes underneath the split. The "share value" is the mathematical y value payload that gets used reconstructed with the polynomial.

When I get dealt a card, which is one of the shares, what am I going to see? A policy, coordinates of where I am going to be in the share. Then there's the payload data. The payload is not just the share value or the split share. It's also wallet information necessary to load in the share. Like a bip32 derivation string. You might not want to reveal this information. The shareholder should have it, but it should be encrypted or hidden. So there's an encrypted blob with all the secrets, and the shares can decrypt the encrypted blob. When you're reconstructing, you need to have the encrypted blob. So that encrypted blob will be included with every share.

There's a publicly viewable thing with every share, and then there's an encrypted blob with each share. And the whole thing should be authenticated. It's an AEAD scheme where each share would have a different authentication tag, because each share will have some slightly different metadata like the x point, and that will need to be authenticated as well. There might be share-specific data which will be possible to define later or maybe something we come up with now. Combining the y values would give you the key to the AEAD scheme, sounds reasonable to me.

You used HMAC and 512 instead of AES? It was chosen so that it would be reversible. So right now, SLIP 39 is only used to split the master secret, which is used in bip32. But maybe you want to split a private key. In that case, you want to go the other direction. You want to first define the secret, then you want to unpassphrase it or encrypt it with a passphrase and then split that. If it's one-directional, then you get a master secret, which you have no control over, and maybe you do want to have control over that master secret because it's some curve or something. So right now it doesn't have a use, but we found that there might exist some use cases such as this one. Could you not just have used AES and decrypted the starting block? We could have, but there's some problems with AES-- padding stuff, as usual, and there's always ways around that. Another problem is that it's a very fast cipher, you want to have some sort of way to include delay, like PBKDFs, and then you now need multiple libraries like PBKDFs and one that does AES.

What symmetric algorithms are in Bitcoin Core right now, codewise? There was a new one recentlyt---- ChaCha20-Poly1305 but it's a bitcoin variant.. There's some others too. I want to minimize the audit footprint. There is an AES library in Bitcoin Core, and then there's ChaCha20-Poly1305 variant, and some PBKDF-- no that's not in Bitcoin Core. I have a preference, not a requirement, that any crypto that we can leverage that is already used in Bitcoin Core, because they have other reasons to audit, that we use that. Are any of those suitable? Bitcoin Core uses HDKDF. If there's not going to be a passphrase in this BIP, then you might not need one. This blob might have passphrases or other stuff, but you're not going to be able to get this blob unless you get your quorum.

I would like there to be an option of putting a verifiable passphrase on each share. So you can leave these things out in the open and not have someone just..... Okay, but now we have moved this to yet another thing that I have to secret share to be reliable to recover this. This would be optional, you don't have to do this. This is a social UX problem. People would say, the experts have put this in here, and therefore I should use it. But it dramatically lowers your reliability. We had this same conversation with SLIP 39. We wanted to put a passphrase on each share... it's just too complex for people. You're just moving your problem around. You can have it optional, I have nothing against that. We can get along with this not being in the standard, though. People also confuse the passphrase for their wallet with the passphrase to decrypt the shares. All the key derivation functions available to Bitcoin Core, honestly I think they should not be used in future protocols because they can be accelerated by an adversary with hardware very easily. There have been alternatives that have done well in competitions recently, but they have not been included in Bitcoin Core. Argon would be interesting, but you can't get it functioning well on a hardware wallet. You would need a lot of RAM to run it well. Argon requires a lot of memory. That's why it works. You can't do it on a Trezor or Ledger though. The alternative is to say, we're going to use this thing which you can do on a Trezor but is not actually as  secure. The true alternative should be, we shouldn't be using a password security for this instance, maybe instead a dual scheme where they need the recovery of two different types of shares. There are other alternatives that are possible as well.

Why are we encrypting it all, if it can't get recovered until we have sufficient quorum until we're able to do this? The whole point of social key recovery is that you've lost it-- so you need to get it from the person you've given your share to.

A shareholder in a corporation has ownership of the corporation, but a shareholder of a share in a social key recovery scheme, is really just a shared custodian. Well then maybe share is a bad word too then. Shard is an alternative. It's a good word. I like shard. There's a "share custodian".

A share custodian might be share custodian for 20 different people and 40 different secrets. The shares need to be tagged and queryable. These cards are going to have information encoded on there, you can also encode it in text, the deck identifier so you know which one. Wolf's position is that the dealer should not put any information about his identity on the cards because then that allows somebody to go, oh, I've stolen this deck of cards and then they have an identifier. Then they can go try to find a quorum based on those people. Should there be verifiable information attached to the shards? There is a master secret and a pre-master secret, having to do with the whole full deck. That then signs the meta information. So that master secret has a public key associated with it that you can use to identify and figure this out.

A share custodian have a "share pool".

I have heard decks, shards, shares, and all of these terms. We should define some of these terms. There's also containers. There's a shard, a share value, a checksum on the whole thing. There's public information on the share that allows the share custodian to identify what to return from his share pool, which is actually bigger than the full deck. No, it's something else. Then we have the authentication of the shard, we have the public stuff that anybody can view. There might need to be a public policy. There would have to be. Then within the thing that is encrypted, we have the fundamental Shamir, and then we have this encrypted blob that is based on the fundamental Shamir but there may also need to be some authentication check on that whole thing. When we come back, let's puzzle out our names and whether we have all the pieces.



