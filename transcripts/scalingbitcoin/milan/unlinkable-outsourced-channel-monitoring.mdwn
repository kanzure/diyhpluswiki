Unlinkable outsourced channel monitoring

Tadge Dryja

<http://lightning.network/>


Okay. Hi everyone. Check. Wow. Check one two. Okay it's working. And I have 25 minutes. Great. So I am going to talk about unlinkable outsourced channel modeling. Everyone likes channels. You can update states. You can link them together to make a network. This is really great. There are risks. These are additional risks. The price of scalability is eternal vigilance. You have to keep watching your channels. This is different from bitcoin. Receiver sends in these channels. When you are receiving bitcoin, you have to be signing. Your wallets are mostly hot. There are a lot of different risks. You have to watch your channel with a full node. Don't use bloom filters. The full node providing you with a merkle block could just lie. So if you're connected to a full node and say here's my ... if you don't know-- if you don't find out that you got some coins, you want to find out. In lightning, you need to know as soon as you can, so that you can grab money back from an invalid close.

Maybe you're not online all the time, but you have friends. Maybe you can ask a friend to watch the channel and send you an email if your channel closes so that you could check and make sure everything's okay. Or you could give them your private key; that's probably a really trusted friend. Or you could give them all transactions, potentially invalid closes, fully signed. Maybe you could give them a reward for finding this for you. This never happens, though. Hopefully the channel never closes in an invalid state, so you're giving them a reward for something that's not supposed to happen. So that doesn't work.

So you store O(log n) data. It's never more than 3 or 4 kilobytes. Even if you have a billion different states in your channel, it's very compact. I'm at state 1 billion, but this is at state 500 million. For a third party to do this in log n, you need a flexible signature. Maybe a MAST or a sighash without signing inputs. So that doesn't work right now. You need at least a signature for every state.

What about privacy? We can't get scalability for the outsourcing quite as well. I think privacy really improves safety in this case. You don't have to worry about people seeing your balances and what transactions oyu're doing. If you have to worry about that, then you're much less likely to outsource. People worry about privacy. If the outsourcing is private, you could have someone watch it, and they wont know what the channel is. So let's give it to lots of people. We want to minimize the trust necessary for channel monitoring outsourcing.

It's a different trust model. It's sort of a trusted third party, but it's a minimized trusted third party.  You kind of want these people to tell about your channels. There's no way to prove that someone will be online tomorrow. The best way to deal with this is to give it to a bunch of people. You only need one person to be online, if you outsource it to ten people. The basic idea of how to keep this private... the simplest way is that a txid does not necessarily reveal the transaction. A signature doesn't reveal the message it's signing. The simplest most straightforward way is to take your transaction, the one that does the repudiation, so what you do is you encrypt the data in that transaction and you use the first half of your txid as your identifier and the second half as the symmetric key encrypting that data. So you give the first 16 bytes of the txid, then you say the next 16 bytes of the txid are the key to decrypt this blob I'm giving you. Given the first half of a txid, can you calculate the second half?

So you can encrypt the signature and the whole script in HLTC, it's about 130 bytes. The signature would be 64 bytes, you could concatenate it a bit. So then there's variable size, variable timing, it's hard to get it perfect. But what about if we wanted a little bit more scalability? Signature alone could be used in osme cases. You only have to store 64 bytes instead of 130 bytes. So that might be 2x better. If you're doing a lot of states, and then 50% space saving is pretty good.

When the observer sees this invalid transaction and detects it, they are able to generate the public key script when they see it. You have a timelock key, and a delay say 3 days, or a revocation key, and the revocation key would be what's given to the other party, it's an ECDSA combination of two keys where you reveal the secret so that they can spend with the revocation key immediately so the person with the revocation key can spend it immediately. You don't want to give the outsourcer the revocation key yourself. You do want to give them the.... you want to let them know what the timeout public key and timeout revocation key are, so that they can spend it themselves. The revocation key changes each state, hash-tree. Timeout key doesn't need to change, but if it's static, then it can identify the channel. If the timeout key is static across the entire channel for all states, ... state one, state two, state three. The timeout key is always the same. So at state three, say it closes. So say I gave the outsourcer old states only. The outsourcers can see state 1 and state 2. They don't know which channel that's referring to. So now they know after the fact, the balance and everything else like that. So if the timeout key is static throughout the channel, yeah we need to change both pubkeys in each state.

So what if we take the intermediate point and add that to the revocation key and timeout key? We don't need to add any new messages to the network or anything like that. At each state change, you change the revocation key and the timeout key. It looks better, but it also doesn't work. I'll show you why. Given the third state, you can't tell, you have the base for the timeout key, you have the base for the revocation key, but you can't tell what point was used at state 3, right? Well, you can. It's the same point being added to both bases. So you can subtract from the observed public key the base that you know, and you can do this with the revocation key observed and revocation key base. So then you know this is the channel you were watching. So you can't do that either; this breaks the anonymity of the channel. For every channel that closes on the network you would have to do a bunch of ECDSA operations, but you could still figure out what's going on.

You have to add two different points, to your counterparty, each new state. Both of those points are the scalars are derived from a hash of a pairing point. So I only need to keep track of the same hash tree and I can do an HMAC where I take my state nonce and hash it with r, hash it with t to get timeout scalar, and then I construct points from them. When you observe, you have no idea, unless you can get back to the parent hash. So this is the same amount of storage, and it cuts down the storage for the outsourcer by 50%. With HLTCs, you have other issues like timing data and other things. So scalability- this helps with scalability. The scalability to an observer is difficult. The observer database can potentially be much larger than the entire blockchain. Say you are an observer monitoring 10,000 channels, and each channel has 1 million states they have been through; that's 10 billion transactions. At 100 bytes per transactions, that 1 terabytes of storage. Each time you get a block, you have to look at all txids and then look at your own partial txids. You could probably do this... I haven't simulated with 10 billion, I did it with 1 million, and it seems okay. I should try it with billions. Okay this is log n, I like log n kind of thing.

Unlinkability is not perfect. There's always going to be this arm race and attacks here. HLTCs you could ignore them and say I'm making HLTCs making payments multi-hop, and I'll just not tell my outsourcer about those. If they are small, that might be an okay strategy. Bulk of the channel might not be on HLTCs. Say you have a 2 bitcoin HLTC and you say, well they are probably not going to close the channel in the wrong way to get those 2 coins because they would lose 9 coins. You could send them noise; you could make up HLTCs and get them to store them. If you know HLTCs are routing through this channel, and I observed more routing data, and such.......

The other tricky thing is that you don't want to give people too many options. If you have three different... even if you have settings in your client where you outsource certain things, that reveals information about your client and then people can try to use that to link the channel schemes. Everyone should use bip69, it's a canonical ordering of inputs and outputs. That's a wallet-specific thing, it otherwise reveals information about the wallet you're using.

If I have a channel and I close it, and then I tell the person monitoring it hey I closed it and you can stop monitoring it. Well if you tell them that, they might check that hey there's only one channel closing on the blockchain, so then they would know that was the channel related to you. Say someone watches 1 GB of data for you for free, and they delete the oldes tone; and then maybe you never actively tell them when you actually delete or clcose a channel rather. You could also add latency or add lag, where you tell your outsourcer only a few minutes later. That could help. There's a bunch of things you can do in this direction. It's never going to be perfectly anonymous or perfectly outsourceable.

Backups of lightning channels are dangerous. Say you make a backup of state 30, then you make some more transactions, then restore your transaction to state 30, I could quickly lose all my money because I restored a backup. If I connect to my counterparty and say hey I'm trying to make state 31, and they will be sure, and they know the 31st revocation key already, so they can just take money. So it's very risky to restore from a backup.







Scalability of lightning with different BIPs <https://scalingbitcoin.org/hongkong2015/presentations/DAY2/1_layer2_2_dryja.pdf>

transcript from Hong Kong <https://diyhpl.us/wiki/transcripts/scalingbitcoin/hong-kong/overview-of-bips-necessary-for-lightning/>

Lightning network as a directed graph: Single-funded channel network topology <https://www.youtube.com/watch?v=-lgYYz3y_hY>

